JavaScriptで各種言語を解析，コード生成するためのライブラリ群です．

[BitArrow](https://github.com/hoge1e3/jslesson)，[Tonyu2](https://github.com/hoge1e3/Tonyu2)
，[Degapper](https://github.com/hoge1e3/Degapper)等で使用されています．

# Parser.js

## 概要

Parser.jsは，字句解析および構文解析の基本となる次のクラスを提供します．

- Stateクラス
- Parserクラス
- StringParserクラス
- TokensParserクラス

Stateオブジェクトは，現在の字句・構文の状態として次の情報を保持します．
- 解析の対象となっている ソースコード（文字列） または 字句列（字句オブジェクトの配列）
- 解析位置（現在何番目の文字または字句を解析中か）

Parserオブジェクトは，Stateオブジェクトを渡すことによりその状態からの解析を行い，
新しいStateオブジェクトに次の情報を入れて返します．

- 解析の対象となっている ソースコード または 字句列（解析前と同じもの）
- （解析が成功した場合）読み取った後の解析位置
- 解析が成功したかどうか
- 解析結果（構文木の配列）

StringParserは，（ソースコードを表す）文字列の解析をするParserオブジェクトを提供します．主に字句解析に用います．

TokensParserは，（字句解析で得られた）字句列の解析をするParserオブジェクトを提供します．主に構文解析に用います．

※Parser.jsはrequire.jsのモジュールとして定義されています．各クラスへは次のようにアクセスしてください．

~~~
requirejs(["Parser"], function (P){
    var Parser=P.Parser;
    var StringParser=P.StringParser;
    ...
});
~~~


----
## Stateクラス

Stateオブジェクトは，現在の字句・構文解析の状態および解析結果を保持します．

### フィールド

- `src` 次のフィールドをもつオブジェクトを格納します
    - `str`  (解析対象が文字列の場合) 解析対象となる文字列
    - `tokens` (解析対象が字句列の場合) 解析対象となる字句の配列
    - `maxPos` 解析位置の最大値（エラー発生時にエラーの場所として使用）
- `pos`  このStateが示す解析位置
- `success`  解析結果：解析が成功したか
- `result`  解析が成功した場合の構文木の配列

## Parserクラス

Parserオブジェクトは，解析を担当します．既存のParserを組み合わせて別のParserを合成する各種メソッドを提供します．

### クラスメソッド

#### Parser::create(f)  

関数fをもとにParserオブジェクトを作成します．fは第１引数にStateオブジェクトを受け取り，解析結果となるStateオブジェクトを新しく生成して返す必要があります．

解析手法には再帰下降法を利用しています．

### メソッド

#### p.parse(state)

このParser(`p`) にStateオブジェクト`state`を渡し，解析を行った結果を表す新しいStateオブジェクトを返します．

#### p.parseStr(str)

このParser(`p`) に文字列`str`を解析させます．戻り値は解析結果を表すStateオブジェクトになります．

#### p.parseTokens(tokens)

このParser(`p`) に字句列`tokens`を解析させます．戻り値は解析結果を表すStateオブジェクトになります．

#### p1.and(p2)

このParser(`p1`)の解析に続き，別のParserオブジェクト`p2` の解析を行う新しいParserを返します（`p1`に続いて`p2`が来る，という構文に相当）．
解析結果となるStateオブジェクトの`result`フィールド(以下，単に`result`と呼ぶ場合があります)には，`p1`の解析結果と`p2`の解析結果とを連結した配列が入ります．

`p1.and(p2).and(p3)` のように３個以上連結することも可能です（この場合，`result`には`p1` `p2` `p3`の解析結果が連結されて格納される）

#### p1.or(p2)

このParser(`p1`)の解析を行い，解析が成功したらその結果を，失敗した場合は`p2`の解析を行う新しいParserオブジェクトを返します．（`p1`または`p2`が来る，という構文に相当．ただし`p1`と`p2`がともに成功する状態では`p1`の結果が優先される）

#### p.rep0()

このParser(`p`)が0個以上繰り返されるという構文を解析する新しいParserオブジェクトを返します．
 - `result`には`p`の構文解析結果の配列（※）が追加されます．

※注意： rep0で生成したParserの結果は，`result`に「配列の配列」として格納されます．例えば `A.and(B.rep0())` というParserの解析結果は，`result`フィールドには `[a, [b0,b1,b2...]]` という形で格納されます（a, b*n* はそれぞれ A ,B によって解析された構文木を表す）．

#### p.rep1()

このParser(`p`)が1個以上繰り返されるという構文を解析する新しいParserオブジェクトを返します．
 - `result`の形式はrep0と同じです．

#### p.sep1(sep)

このParser(`p`)を，セパレータをあらわす構文`sep`を挟みながら1個以上繰り返すという構文を解析する新しいParserオブジェクトを返します．
 - `result`に追加される要素は`p`の構文木の配列になります．
   - この配列の[1]以降の要素からシンボル`Parser.SEP` を介して，要素の直前のセパレータの要素にアクセスできます．

#### p.sep0(sep)

p.sep1と同様ですが，要素が０個の場合も解析に成功し，要素０の配列を返します．

#### p.ret(f)

このParser(`p`)と同じ構文を解析しますが，`result`の内容を関数`f`で加工する新しいParserオブジェクトを作成します．

- 関数`f`は，`p`による`result`の各要素が引数に渡されて呼ばれます．
- 加工された後の`result`は，`f`の戻り値ただ１つを要素にもつ配列になります（`result==[fの戻り値]`)

例えば，`E.and(E).ret((left,right)=>{left,right})` は，Eが2つ連続するものを解析し，関数では1個目のEの構文木をleft, 2個目のEの構文木をright に入れたオブジェクトを返します．`result`は`[{left:1個目のEの構文木,left:2個目のEの構文木}]` になります．


## StringParserクラス

文字列の解析をするParserオブジェクトを提供します．主に字句解析に用います．

### StringParser.str(s)

現在の解析位置に文字列`s`がある場合のみ解析に成功するParserオブジェクトを返します．
- 成功した場合，`result`には`[{pos:解析前の解析位置, text:s ,len:sの長さ}]`が入ります．解析位置は`s`の長さ分進みます．

### StringParser.reg(r)

現在の解析位置からの文字列が正規表現`r`にマッチする場合のみ解析に成功するParserオブジェクトを返します．

- `r`は必ず ^ (先頭にマッチする) で始める必要があります．
- 成功した場合，`result`には`[{pos:解析前の解析位置, text:rにマッチした文字列, len:文字列の長さ}]`が入ります．解析位置は`r`にマッチした文字列の長さ分進みます．

### StringParser.strLike(f)

現在の解析位置から関数`f`であらわされる条件を満たした場合に成功するParserオブジェクトを返します．

- `f`は次を引数を渡されて呼ばれます
    - 解析中の文字列（これまで解析した部分も含まれる）
    - 現在の解析位置
    - Stateオブジェクト（第2引数はこのオブジェクトのposフィールド）
- `f`は，解析が失敗する場合はnullを，成功した場合は `{len:取り出した文字列の長さ}` を返す必要があります．
- このParserオブジェクトの`result`には`[{pos:解析前の解析位置, text:取り出した文字列, len:文字列の長さ}]`が入ります．解析位置は取り出した文字列の長さ分進みます．


## TokensParserクラス

字句列の解析をするParserオブジェクトを提供します．主に構文解析に用います．

字句列は，次のようなオブジェクトの配列として表現されます．

`{type: 字句の種類を表す文字列, pos:解析位置, text:取り出した文字列, len:文字列の長さ}`

#### TokensParser.token(type)

- 現在の解析位置に，字句の種類が`type`に一致するトークンがある場合に成功するParserオブジェクトを返します．`result`には該当する字句オブジェクトだけからなる配列が入ります．

# Grammar.js

## Grammarクラス

Parserオブジェクトをより簡便に使うための「構文式」を提供します．

### コンストラクタ

`new Grammar(options)`

`options`は省略可能．次のフィールドをもつオブジェクトを渡すことができます．

- `space` （字句解析時のみ）字句の要素から除外する要素（空白）をあらわす正規表現を指定します．

### g.def(defs)

構文を定義します．`defs`には次の形式でオブジェクトを指定します．

`{"構文名" :  構文式  }`

構文式には次のいずれかの記述が可能です：

- Parserオブジェクト： Parserオブジェクトで表される構文そのものを表します
- `"構文名"`：  指定された構文名（このGrammerオブジェクト`g`で定義されているもの）をもつ構文を表します
- `"'文字列"`：  （字句解析時のみ）指定された文字列を字句として解析する構文を表します．
- `/^正規表現/`：  （字句解析時のみ）指定された正規表現にマッチする字句を解析する構文を表します．
- `[構文式0 ,  構文式1,  .... 構文式n ]` : 構文式で表される構文を順番に解析する構文を表します．
    - 解析結果は`{"0":構文式0の解析結果, "1":構文式1の解析結果,....  "n":構文式nの解析結果}`というフィールドをもつオブジェクトになります(※`"n"` は，nという英字ではなく，配列の要素数-1 を表す数値を文字列化したもの)．
    - 解析結果のオブジェクトには`type`というフィールドに構文名が文字列で入ります．
    - `[構文式0 ,  {フィールド名: 構文式1 },  .... 構文式n ]` のように記述すると，`構文式1`の解析結果が，指定されたフィールドにも代入されます．
    - 注意： Parserオブジェクトが再帰下降法を利用しているため，要素の先頭に定義しようとしている構文名そのものを書くとスタックあふれが発生し解析できません．(例： `{expr:["expr,"elem"], elem: ....}`  )
- `g.rep0(構文式)`  : 構文式が0回以上繰り返される構文を表します．
    - 解析結果は構文木の配列になります．
    - rep1も同様に書けます(構文式が１回以上繰り返される)．
- `g.sep1(構文式e, 構文式s)`  : 構文式eを，構文式sを間に挟みながら1回以上繰り返すという構文を表します．
    - 解析結果は構文木eで解析した要素の配列になります．
        - 構文木sの要素には，この配列の[1]以降の要素からシンボルParser.sepを通じてアクセスできます．
    - sep0も同様に書けます．(構文式eが０回以上繰り返される)
- `g.or(構文式, 構文式.... )`: 指定された構文式のいずれかを解析する構文を表します．
    - 入力が複数の構文式に一致する場合，前に書いた構文式が優先されます．

### g.get(name)

g.defで定義された構文から，`name`で指定される構文名をもつ構文をあらわすParserオブジェクトを返します．

### g.expr(defs)

`x+10*z` のような式を解析するParserオブジェクトを生成します．

defs には次のフィールドをもつオブジェクトを指定します．

- `element`:  式の要素（`x`,`10`など，演算子で連結される対象)をあらわす構文を構文式で指定します
- `operators`:  式で利用可能な演算子を，優先順位の低いもの（後に計算される; 構文木の上位階層)から順に配列で列挙します．それぞれの演算子は，[`type`,`op`]という要素２の配列で表現します．
    - `type`:  `"prefix"`(前置単項演算子)，`"postfix"`(後置単項演算子)，`"infixl"`(左結合2項演算子)，`"infixr"`(右結合2項演算子)，`"trifixr"`(3項演算子) のいずれかを指定します．
    - `op`:  演算子をあらわす構文を構文式で指定します．
- 解析結果の構文木は，演算子の種類によって次のようなオブジェクトになります
    - `"prefix"` : `{op:演算子の構文木, right: 演算対象の構文木}`
    - `"postfix"` : `{left: 演算対象の構文木, op:演算子の構文木}`
    - `"infixl"`, `"infixr"` : `{left: 演算対象(左側)の構文木, op:演算子の構文木, right: 演算対象(右側)の構文木}`
    - `"trifixr"` : `{left: 演算対象(左側)の構文木, op1:1番目の演算子の構文木, mid: 演算対象（中央）の構文木,  op2:2番目の演算子の構文木,right: 演算対象(右側)の構文木}`

# Visitor.js

## Visitorクラス

Parserが生成した構文木を辿って（訪問=visit して）コード生成や意味解析を行います．

構文木はオブジェクトで表現され，各ノードの`type`というフィールドに構文名をあらわす文字列が格納されている必要があります（Grammarクラスを用いて解析した構文木はこの要件を満たすように生成されています）．

### コンストラクタ

- Visitor(`vdefs`)

`vdefs`には次のようなキーと値をもつオブジェクトを指定します．

- キー：  ノードの構文名（`type`フィールドの値）
- 値： キーで指定された構文名のノードを訪問したときに行う処理を表す関数
  - 関数のthisにはこのVisitorオブジェクト，第1引数に訪問しているnodeが格納されます．


### フィールド

- def
  - `vdefs` に定義されていない構文名のノードを訪問したときの処理をあらわす関数

### メソッド

- visit(node)
  - 指定されたnode に訪問します．
- printf
  - 後述のCodeGenオブジェクトと連携している場合のみ有効：CodeGenオブジェクトのprintfへのショートカットです．

# CodeGen.js

## CodeGen クラス

コード生成に必要な出力メソッドを提供します．

### コンストラクタ

- CodeGen(`options`)
  - options には次を指定できます
    - `visitor`: Visitorオブジェクトと連携する場合，Visitorオブジェクトを指定します

### メソッド

- printf(format, ...params)
  - 指定されたフォーマットでコードを出力します．
  - 書式文字列に指定できるのは次のものです
    - `%s` 値を文字列を出力します．文字列以外のものについてはString.valueOfで変換します（字句ノードは自動的にもとのソースコード内の文字列に変換されます）
    - `%v`  Visitorオブジェクトと連携している場合のみ有効．指定されたノードを訪問します．訪問中に出力した内容がこの位置に出力されます．
    - `%{`  改行し，次行からインデントを１つ増やします．
    - `%n`  改行し，改行前の行と同じインデントを挿入します．
    - `%}`  現在の行のインデントを１つ減らします．必ず`%n`に続いて行う必要があります．
    - `%j`  値として要素２の配列を指定します．[0]番目の要素にセパレータ，[1]番目の要素に配列を指定します．[1]番目の要素に指定された配列の要素を，セパレータで区切って並べて出力します．
        - 例：  printf("%j",["-",[1,2,3]]); // => 1-2-3
- close()
  - 出力を完了し，出力された内容を文字列で返します．
